{% extends "layout.html" %}

{% block title %}Jobs Map — GetAJob{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  /* Map page layout */
  .map-card {
    max-width:1100px;
    margin:18px auto;
    padding:12px;
  }

  .map-wrapper {
    display:flex;
    gap:12px;
    align-items:stretch;
    min-height:56vh;
  }

  /* Map canvas */
  #map {
    position: relative;
    flex:1;
    /* keep the map height bounded so it cannot grow indefinitely */
    height: min(56vh, 720px);
    min-height: 360px;
    max-height: 80vh;
    width:100%;
    border-radius:8px;
    border:1px solid rgba(0,0,0,0.06);
    background:#f3f5f7;
    overflow:hidden;
    z-index:0;
    box-sizing: border-box;
  }

  /* Static-image fallback inside map when tiles fail */
  #map img.static-fallback {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 0;
  }

  /* Overlay used for library/tile error messages */
  #mapOverlay {
    position: absolute;
    inset: 0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    background: rgba(255,255,255,0.6);
    z-index: 1000;
    font-size:1rem;
    color:#333;
  }
  #mapOverlay.hidden { display:none; pointer-events:none; }

  .sidebar {
    width:320px;
    max-width:34%;
    display:flex;
    flex-direction:column;
  }

  .sidebar .card {
    padding:8px;
    border-radius:8px;
    background:#fff;
    border:1px solid rgba(0,0,0,0.06);
    height:100%;
    overflow:auto;
  }

  .job-list-mini { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px; }
  .job-list-mini a { display:block; padding:8px; border-radius:6px; text-decoration:none; color:var(--text); border:1px solid rgba(0,0,0,0.04); background:#fff; }
  .job-empty { color:var(--muted); padding:12px; }

  .map-controls { display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap; align-items:center; }
  .map-controls input[type="search"], .map-controls select { padding:8px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); }
  .map-controls .btn { padding:8px 10px; border-radius:6px; }

  .suggestions-list { position:relative; max-height:200px; overflow:auto; margin-top:6px; border:1px solid rgba(0,0,0,0.06); border-radius:6px; background:#fff; z-index:1000; }
  .suggestions-list button { width:100%; text-align:left; padding:8px; border:0; background:transparent; cursor:pointer; }

  /*
    Prevent global img rules (e.g., img { max-width:100% }) from breaking Leaflet tiles.
  */
  .leaflet-container img {
    max-width: none !important;
    display: block !important;
    image-rendering: auto !important;
  }
  .leaflet-container .leaflet-tile {
    width: 256px !important;
    height: 256px !important;
  }

  @media (max-width:900px) {
    .map-wrapper { flex-direction:column; }
    .sidebar { width:100%; max-width:100%; }
    #map { height:420px; min-height:360px; max-height:70vh; }
  }
</style>
{% endblock %}

{% block content %}
<div class="card map-card">
  <div class="map-wrapper">
    <div id="map" aria-label="Jobs map">
      <!-- overlay is hidden by default; shown only for library-missing or persistent tile failure -->
      <div id="mapOverlay" class="hidden">Loading map…</div>
    </div>

    <aside class="sidebar">
      <div class="card">
        <div class="map-controls" role="toolbar" aria-label="Map controls">
          <button id="btnLocate" class="btn btn-outline" title="Use browser location">Locate me</button>

          <div style="flex:1;">
            <div class="search-suggestions">
              <input id="addrSearch" type="search" placeholder="Search address or place..." style="width:100%;" />
              <div id="suggestions" class="suggestions-list" style="display:none;"></div>
            </div>
          </div>

          <select id="radiusSelect" title="Radius (miles)">
            <option value="5">5 mi</option>
            <option value="10" selected>10 mi</option>
            <option value="25">25 mi</option>
            <option value="50">50 mi</option>
          </select>
          <button id="btnApply" class="btn btn-primary">Search</button>
        </div>

        <h3 style="margin-top:6px;">Jobs nearby</h3>
        <div id="jobsList" style="margin-top:6px;">
          <div class="job-empty">Locating and loading jobs...</div>
        </div>
      </div>
    </aside>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* Ensure marker images are pulled from unpkg (avoid local 404s).
   This must run after leaflet.js is available. */
if (window.L && L.Icon && L.Icon.Default) {
  L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'
  });
}

/* Default Carto tile URL for light assignment use. Can be overridden by passing TILE_URL from Flask. */
const CARTO_TILE_URL = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png';

(function () {
  // safeguard flags to prevent repeated init/switch storms
  let mapInitInProgress = false;
  let primarySwitching = false;

  // Helper: escape HTML for popup content
  function escapeHtml(s) {
    if (s === null || s === undefined) return '';
    return String(s).replace(/[&<>"']/g, function (m) {
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m];
    });
  }

  const btnLocate = document.getElementById('btnLocate');
  const addrSearch = document.getElementById('addrSearch');
  const suggestionsEl = document.getElementById('suggestions');
  const btnApply = document.getElementById('btnApply');
  const radiusSelect = document.getElementById('radiusSelect');
  const jobsListEl = document.getElementById('jobsList');
  const mapEl = document.getElementById('map');
  const mapOverlay = document.getElementById('mapOverlay');

  let map = null, markersLayer = null, userMarker = null, radiusCircle = null;
  let currentCenter = { lat: 39.8283, lng: -98.5795 }; // default US center
  let currentRadius = Number(radiusSelect.value) || 10; // miles

  function showOverlay(msg) {
    if (!mapOverlay) return;
    mapOverlay.textContent = msg || '';
    mapOverlay.classList.remove('hidden');
  }
  function hideOverlay() {
    if (!mapOverlay) return;
    mapOverlay.classList.add('hidden');
  }

  // Haversine: distance in miles
  function haversineMiles(lat1, lon1, lat2, lon2) {
    const toRad = v => v * Math.PI / 180;
    const R = 3958.8; // miles
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    return 2 * R * Math.asin(Math.sqrt(a));
  }

  // Build a staticmap URL for fallback (single image, not interactive)
  function staticMapUrl(lat, lon, zoom) {
    const z = zoom || 4;
    const size = '1024x512';
    return `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lon}&zoom=${z}&size=${size}&markers=${lat},${lon},red-pushpin`;
  }

  // Append a static fallback image into the map container (removes leaflet layers)
  function showStaticFallback(lat, lon, zoom) {
    // Ensure we remove any existing leaflet map and panes to avoid duplicates
    try {
      if (map) {
        map.remove();
        map = null;
        window.__jobs_map_inited = false;
      }
    } catch (e) { /* ignore */ }

    // remove any existing fallback img
    const existing = mapEl.querySelector('img.static-fallback');
    if (existing) existing.remove();

    const img = document.createElement('img');
    img.className = 'static-fallback';
    img.alt = 'Map preview';
    img.src = staticMapUrl(lat, lon, zoom || 4);
    // hide overlay (we show the image)
    hideOverlay();
    mapEl.appendChild(img);
  }

  function removeStaticFallback() {
    const existing = mapEl.querySelector('img.static-fallback');
    if (existing) existing.remove();
  }

  function initMapOnce() {
    // If Leaflet missing, show overlay and bail
    if (!window.L || !window.L.map) {
      console.warn('Leaflet not available');
      showOverlay('Map library not loaded');
      showStaticFallback(currentCenter.lat, currentCenter.lng, 4);
      return;
    }
    if (window.__jobs_map_inited) return;
    window.__jobs_map_inited = true;

    // Get map element
    const mapEl = document.getElementById('map');

    // CRITICAL: Clean up any existing Leaflet debris
    mapEl.innerHTML = '<div id="mapOverlay" class="hidden">Loading map…</div>';
    mapEl.style.cssText = `
      position: relative;
      flex: 1;
      min-height: 400px;
      height: 500px;
      width: 100%;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.06);
      background: #f3f5f7;
      overflow: hidden;
      z-index: 0;
    `;

    // Create map with FIXED viewport
    map = L.map('map', {
      preferCanvas: true,
      maxBounds: L.latLngBounds(
        L.latLng(-85, -180),
        L.latLng(85, 180)
      ),
      maxBoundsViscosity: 1.0,
      worldCopyJump: false,
      zoom: 10,
      center: [currentCenter.lat, currentCenter.lng],
      fadeAnimation: false,
      zoomAnimation: false,
      markerZoomAnimation: false,
      zoomSnap: 0,
      zoomDelta: 0.5,
      inertia: false
    });

    // Force map size BEFORE adding tiles
    setTimeout(() => {
      if (map) {
        map.invalidateSize(true);
        const size = map.getSize();
        if (size.y > 1000) {
          map.getContainer().style.height = '500px';
          map.getContainer().parentElement.style.height = '500px';
          map.invalidateSize(true);
        }
      }
    }, 100);

    // Tile layer with EXPLICIT limits
    const tileUrl = '{{ TILE_URL|default("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png") }}';
    const tileAttr = '{{ TILE_ATTRIBUTION|default("&copy; OpenStreetMap contributors & CARTO")|e }}';

    const tileOpts = {
      attribution: tileAttr,
      maxZoom: 18,
      minZoom: 3,
      bounds: [[-85, -180], [85, 180]],
      noWrap: true,
      updateWhenIdle: true,
      updateWhenZooming: false,
      keepBuffer: 1,
      crossOrigin: true,
      reuseTiles: true,
      tileSize: 256,
      zoomOffset: 0,
      errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
    };

    const primaryTiles = L.tileLayer(tileUrl, tileOpts).addTo(map);

    // CRITICAL: Monkey-patch Leaflet to prevent infinite height
    const originalSetPosition = L.GridLayer.prototype._setPosition;
    L.GridLayer.prototype._setPosition = function() {
      const container = this._container;
      if (container) {
        container.style.maxHeight = '500px';
        container.style.height = '100%';
        container.style.overflow = 'hidden';
      }
      return originalSetPosition.call(this);
    };

    // Monitor and fix tile positions
    primaryTiles.on('tileload', function(e) {
      const tile = e.tile;
      if (tile) {
        tile.style.position = 'absolute';
        tile.style.maxHeight = '256px';
        tile.style.maxWidth = '256px';
      }
    });

    // Fallback tiles (CartoCDN)
    const fallbackUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png';
    const fallbackOpts = { attribution: '&copy; OpenStreetMap contributors & CartoDB', maxZoom: 19 };
    const fallbackTiles = L.tileLayer(fallbackUrl, fallbackOpts);

    markersLayer = L.layerGroup().addTo(map);

    userMarker = L.circleMarker([currentCenter.lat, currentCenter.lng], {
      radius: 8,
      fillColor: getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#0ea5a4',
      color: '#fff',
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
    }).addTo(map);
    userMarker.setStyle({ opacity: 0, fillOpacity: 0 });

    // controls wiring
    btnLocate.addEventListener('click', locateAndApply);
    btnApply.addEventListener('click', () => {
      currentRadius = Number(radiusSelect.value) || currentRadius;
      const center = map ? map.getCenter() : {lat: currentCenter.lat, lng: currentCenter.lng};
      currentCenter.lat = center.lat;
      currentCenter.lng = center.lng;
      loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
    });
    radiusSelect.addEventListener('change', () => {
      currentRadius = Number(radiusSelect.value) || currentRadius;
      if (currentCenter && currentCenter.lat && currentCenter.lng) {
        loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
      }
    });

    let debounceTimer = null;
    addrSearch.addEventListener('input', function () {
      clearTimeout(debounceTimer);
      const q = (this.value || '').trim();
      if (!q) {
        suggestionsEl.style.display = 'none';
        suggestionsEl.innerHTML = '';
        return;
      }
      debounceTimer = setTimeout(() => doAddressLookup(q), 300);
    });

    // invalidate once after mount to ensure sizing
    setTimeout(() => { try { map.invalidateSize(); } catch (e) {} }, 300);
    let winResizeTimer = null;
    window.addEventListener('resize', () => {
      if (winResizeTimer) clearTimeout(winResizeTimer);
      winResizeTimer = setTimeout(() => { try { map.invalidateSize(); } catch (e) {} }, 200);
    });

    // Tile error handling and switch to fallback or static image if required.
    let primaryErrors = 0;
    const primaryErrorThreshold = 6; // number of tile errors to consider provider failing

    function trySwitchToFallbackOrStatic() {
      try {
        if (map && map.hasLayer(primaryTiles)) map.removeLayer(primaryTiles);
      } catch (e) { /* ignore */ }

      // Try fallback tiles first
      try {
        if (!map.hasLayer(fallbackTiles)) {
          fallbackTiles.addTo(map);
        }
      } catch (e) {
        console.error('fallback tile add failed', e);
      }

      // If fallback also doesn't load within a short period, replace with static image
      let fallbackLoaded = false;
      fallbackTiles.once('load', function () { fallbackLoaded = true; hideOverlay(); try { map.invalidateSize(); } catch (e) {} });
      fallbackTiles.once('tileerror', function (e) { console.warn('fallback tile error', e); });

      setTimeout(() => {
        if (!fallbackLoaded) {
          console.warn('Fallback tiles not loading — showing static fallback image');
          // show a single static image preview to avoid blank UI and stop tile storms
          showStaticFallback(currentCenter.lat, currentCenter.lng, 4);
        }
      }, 2500);
    }

    primaryTiles.on('load', function () {
      hideOverlay();
      try { map.invalidateSize(); } catch (e) {}
    });

    primaryTiles.on('tileerror', function (e) {
      primaryErrors++;
      console.warn('Primary tile error', primaryErrors, e);
      // If many primary tileerrors, switch to fallback or static preview
      if (primaryErrors >= primaryErrorThreshold) {
        showOverlay('Primary map provider failed — switching to fallback');
        trySwitchToFallbackOrStatic();
      }
    });

    fallbackTiles.on('tileerror', function (e) {
      console.error('Fallback tile error', e);
      // Let the static fallback logic handle showing image after timeout
    });

    // If tiles are very slow, reveal map (don't block UI indefinitely)
    let tilesLoaded = false;
    const markLoaded = () => { tilesLoaded = true; hideOverlay(); try { map.invalidateSize(); } catch (e) {} };
    primaryTiles.once('load', markLoaded);
    fallbackTiles.once('load', markLoaded);

    setTimeout(() => {
      if (!tilesLoaded) {
        console.warn('Tiles not loaded after timeout — revealing map for user interaction.');
        hideOverlay();
      }
    }, 8000);

    // initial locate flow
    (async function initialLocate() {
      const ok = await tryBrowserGeolocation();
      if (!ok) {
        try {
          const resp = await fetch('/_client_location');
          const j = await resp.json();
          if (j && j.ok && j.lat && j.lon) {
            currentCenter.lat = j.lat;
            currentCenter.lng = j.lon;
            setUserLocationMarker(j.lat, j.lon, true);
            currentRadius = Number(radiusSelect.value) || currentRadius;
            loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
            return;
          }
        } catch (e) { console.warn('IP geolookup failed', e); }
        // no location available; load all jobs (unfiltered)
        loadJobsAndRender();
      }
    })();
  }

  async function locateAndApply() {
    const ok = await tryBrowserGeolocation();
    if (!ok) {
      alert('Unable to get browser location. Check permissions.');
    }
  }

  async function tryBrowserGeolocation() {
    if (!navigator.geolocation) return false;
    return new Promise(resolve => {
      let settled = false;
      navigator.geolocation.getCurrentPosition(async (pos) => {
        settled = true;
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        currentCenter.lat = lat;
        currentCenter.lng = lng;
        currentRadius = Number(radiusSelect.value) || currentRadius;
        setUserLocationMarker(lat, lng, true);
        map && map.setView([lat, lng], 13);
        await loadJobsAndRender(lat, lng, currentRadius);
        resolve(true);
      }, (err) => {
        console.warn('geolocation error', err);
        if (!settled) resolve(false);
      }, { maximumAge: 60 * 1000, timeout: 8000, enableHighAccuracy: false });
      setTimeout(() => { if (!settled) resolve(false); }, 9000);
    });
  }

  function setUserLocationMarker(lat, lng, show=true) {
    if (!userMarker) return;
    try {
      userMarker.setLatLng([lat, lng]);
    } catch (e) { /* ignore */ }
    if (show) {
      userMarker.setStyle({ opacity: 1, fillOpacity: 1 });
      if (radiusCircle) map.removeLayer(radiusCircle);
      radiusCircle = L.circle([lat, lng], { radius: (currentRadius || 10) * 1609.344, color: '#0077ff', opacity: 0.12, weight: 1, fillOpacity: 0.04 }).addTo(map);
    } else {
      userMarker.setStyle({ opacity: 0, fillOpacity: 0 });
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    }
  }

  async function doAddressLookup(q) {
    const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=6&q=' + encodeURIComponent(q);
    try {
      const resp = await fetch(url, { headers: { 'Accept-Language': 'en' } });
      const arr = await resp.json();
      suggestionsEl.innerHTML = '';
      if (!Array.isArray(arr) || arr.length === 0) { suggestionsEl.style.display = 'none'; return; }
      arr.forEach(item => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.innerHTML = escapeHtml(item.display_name);
        btn.addEventListener('click', function () {
          const lat = parseFloat(item.lat), lon = parseFloat(item.lon);
          currentCenter.lat = lat;
          currentCenter.lng = lon;
          setUserLocationMarker(lat, lon, true);
          suggestionsEl.style.display = 'none';
          suggestionsEl.innerHTML = '';
          addrSearch.value = item.display_name;
          currentRadius = Number(radiusSelect.value) || currentRadius;
          map && map.setView([lat, lon], 13);
          loadJobsAndRender(lat, lon, currentRadius);
        });
        suggestionsEl.appendChild(btn);
      });
      suggestionsEl.style.display = 'block';
    } catch (e) {
      console.error('address lookup failed', e);
      suggestionsEl.style.display = 'none';
    }
  }

  async function loadJobsAndRender(lat=null, lng=null, radius=null) {
    try {
      let url = '/api/jobs';
      if (lat !== null && lng !== null) {
        url = '/api/jobs_nearby?lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng);
        if (radius) url += '&radius_miles=' + encodeURIComponent(radius);
      }
      const resp = await fetch(url);
      if (!resp.ok) { jobsListEl.innerHTML = '<div class="job-empty">Unable to load jobs</div>'; return; }
      const j = await resp.json();
      const jobs = (j.jobs || []);
      renderJobsOnMap(jobs, lat, lng);
    } catch (e) {
      console.error('loadJobsAndRender error', e);
      jobsListEl.innerHTML = '<div class="job-empty">Error loading jobs</div>';
    }
  }

  function renderJobsOnMap(jobs, centerLat=null, centerLng=null) {
    if (!markersLayer) return;
    markersLayer.clearLayers();
    if (radiusCircle) { try { map.removeLayer(radiusCircle); } catch (e) {} radiusCircle = null; }

    jobsListEl.innerHTML = '';
    if (!jobs || jobs.length === 0) {
      jobsListEl.innerHTML = '<div class="job-empty">No jobs available.</div>';
      if (centerLat && centerLng && map) map.setView([centerLat, centerLng], 11);
      return;
    }

    let listHtml = '';
    const layers = [];
    const jobDetailTemplate = '{{ url_for("job_detail", job_id=0) }}';

    const centerProvided = (centerLat !== null && centerLng !== null && Number.isFinite(centerLat) && Number.isFinite(centerLng));
    const radiusMiles = Number(currentRadius) || null;

    jobs.forEach(job => {
      const lat = job.lat !== null ? Number(job.lat) : null;
      const lng = job.lng !== null ? Number(job.lng) : null;
      const displayLoc = job.short_location || (job.location_text||'').split(',').slice(0,2).join(', ');

      // Create job detail URL once
      const jobUrl = (jobDetailTemplate.replace('/0','/' + encodeURIComponent(job.id)));

      // Build popup HTML (same as before)
      const popupHtml = '<div><strong>' + escapeHtml(job.title||'') + '</strong>' +
                        '<div style="font-size:12px;color:#666;margin-top:4px;">' + escapeHtml(displayLoc) + (job.distance_miles ? (' • ' + job.distance_miles + ' mi') : '') + '</div>' +
                        '<div style="margin-top:8px;">' + escapeHtml((job.description||'').substring(0,200)) + (job.description && job.description.length > 200 ? '...' : '') + '</div>' +
                        '<div style="margin-top:6px;"><a href="' + jobUrl + '">View job</a> • ' +
                        '<a href="/messages?other_id=' + encodeURIComponent(job.employer_id) + '">Message Poster</a></div></div>';

      // Determine if this job is inside the radius (when center provided).
      let withinRadius = true;
      if (centerProvided) {
        // Prefer server-provided distance if available, otherwise compute.
        let dist = null;
        if (job.distance_miles !== undefined && job.distance_miles !== null && job.distance_miles !== '') {
          dist = Number(job.distance_miles);
        } else if (lat !== null && lng !== null) {
          dist = haversineMiles(centerLat, centerLng, lat, lng);
        }
        if (dist === null) {
          // If we don't know the distance, be conservative: skip placing marker
          withinRadius = false;
        } else {
          withinRadius = (radiusMiles === null) ? true : (dist <= radiusMiles + 0.0001);
        }
      }

      // Add marker only if coordinates exist and (when center given) the job is within radius.
      if (lat !== null && lng !== null && Number.isFinite(lat) && Number.isFinite(lng) && markersLayer && withinRadius) {
        try {
          const marker = L.marker([lat, lng], { title: job.title || 'Job' }).addTo(markersLayer);
          marker.bindPopup(popupHtml, { maxWidth: 300 });

          // Clicking the marker navigates to the job detail page (makes it directly clickable)
          marker.on('click', function () {
            window.location.href = jobUrl;
          });

          layers.push(marker);
        } catch (e) {
          console.warn('Failed to add marker', e);
        }
      }

      listHtml += '<a href="' + jobUrl + '"><strong>' + escapeHtml(job.title||'') + '</strong>' +
                  '<div style="font-size:12px;color:#666;margin-top:4px;">' + escapeHtml(displayLoc) + (job.distance_miles ? (' • ' + job.distance_miles + ' mi') : '') + '</div></a>';
    });

    jobsListEl.innerHTML = '<div class="job-list-mini">' + listHtml + '</div>';

    if (centerProvided && map) {
      try {
        radiusCircle = L.circle([centerLat, centerLng], { radius: (currentRadius || 10) * 1609.344, color: '#0077ff', opacity: 0.12, weight: 1, fillOpacity: 0.04 }).addTo(map);
        map.setView([centerLat, centerLng], 13);
      } catch (e) {}
    } else {
      if (layers.length > 0 && map) {
        try {
          const group = L.featureGroup(layers);
          map.fitBounds(group.getBounds().pad(0.12));
        } catch (e) {
          console.warn('fitBounds failed', e);
        }
      }
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMapOnce);
  } else {
    setTimeout(initMapOnce, 50);
  }
})();
</script>
{% endblock %}
