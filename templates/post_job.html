{% extends "layout.html" %}
{% block title %}Post Job — GetAJob{% endblock %}

{% block content %}
<h2 style="color:var(--primary); margin-bottom:12px;">Post a job</h2>

<div class="form-card">
  <form method="post" action="{{ url_for('post_job') }}" id="postJobForm" autocomplete="off">
    <label>Title</label>
    <input name="title" class="input" type="text" required value="{{ title or '' }}">

    <label style="margin-top:12px;">Description</label>
    <textarea name="description" class="input" required>{{ description or '' }}</textarea>

    <label style="margin-top:12px;">Location (address)</label>
    <div style="position:relative;">
      <input id="locationText" name="location_text" class="input" type="text" value="{{ location_text or '' }}" placeholder="Street, City, State or City, Country" aria-autocomplete="list" aria-haspopup="true" aria-expanded="false" />
      <div id="addrSuggestions" role="listbox" aria-label="Address suggestions" style="display:none; position:absolute; left:0; right:0; top:calc(100% + 6px); z-index:60;"></div>
    </div>

    <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
      <button type="button" id="findAddrBtn" class="btn btn-outline">Find address</button>
      <div id="geocodeStatus" class="small text-muted" aria-live="polite" style="min-width:220px;"></div>
    </div>

    <!-- hidden lat/lng fields (server will geocode if these are empty) -->
    <input type="hidden" id="latHiddenForServer" name="lat" value="{{ lat or '' }}">
    <input type="hidden" id="lngHiddenForServer" name="lng" value="{{ lng or '' }}">

    <div id="previewWrapper" style="margin-top:12px; display:none;">
      <div style="font-size:0.95rem; color:var(--muted); margin-bottom:6px;">Preview location</div>
      <img id="previewMap" src="" alt="Location preview" style="width:100%; max-width:420px; border-radius:8px; border:1px solid rgba(0,0,0,0.06);">
    </div>

    <div style="display:flex; gap:12px; margin-top:12px;">
      <div style="flex:1;">
        <label>Lat (optional)</label>
        <input id="latManual" name="lat_manual" class="input" type="text" placeholder="Optional — auto filled" value="{{ lat or '' }}">
      </div>
      <div style="flex:1;">
        <label>Lng (optional)</label>
        <input id="lngManual" name="lng_manual" class="input" type="text" placeholder="Optional — auto filled" value="{{ lng or '' }}">
      </div>
    </div>

    <label style="margin-top:12px;">Salary</label>
    <input name="salary" class="input" type="text" value="{{ salary or '' }}">

    <label style="margin-top:12px;">Tags (comma separated)</label>
    <input name="tags" class="input" type="text" value="{{ tags or '' }}" placeholder="e.g. remote,python">

    <div class="form-actions" style="margin-top:14px;">
      <button class="btn btn-primary" type="submit">Post job</button>
      <!-- updated: use client_dashboard (exists in app.py) to avoid BuildError -->
      <a class="btn btn-outline" href="{{ url_for('client_dashboard') }}">Cancel</a>
    </div>
  </form>
</div>
{% endblock %}

{% block scripts %}
<style>
/* minimal dropdown styling — placed here so no extra CSS file changes required */
#addrSuggestions { background:#fff; border:1px solid rgba(0,0,0,0.08); border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.06); max-height:240px; overflow:auto; padding:6px; }
.addr-suggestion { padding:8px 10px; cursor:pointer; border-radius:6px; font-size:0.95rem; color:var(--text); }
.addr-suggestion:hover, .addr-suggestion[aria-selected="true"] { background: rgba(216,111,42,0.06); }
.addr-suggestion small { display:block; color:var(--muted); font-size:0.82rem; margin-top:4px; }
</style>

<script>
(function(){
  function debounce(fn, wait){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), wait); }; }

  const locInput = document.getElementById('locationText');
  const suggestions = document.getElementById('addrSuggestions');
  const statusEl = document.getElementById('geocodeStatus');
  const preview = document.getElementById('previewMap');
  const previewWrapper = document.getElementById('previewWrapper');
  const latHidden = document.getElementById('latHiddenForServer');
  const lngHidden = document.getElementById('lngHiddenForServer');
  const latManual = document.getElementById('latManual');
  const lngManual = document.getElementById('lngManual');
  const findBtn = document.getElementById('findAddrBtn');

  let items = [];        // suggestions array
  let selectedIndex = -1;

  // Bias coordinates (will be set by determineBiasCoord)
  let biasLat = null, biasLon = null;

  // Fallback default: New York City center
  const DEFAULT_FALLBACK = { lat: 40.7128, lon: -74.0060 };

  // degrees delta for viewbox bias (smaller => tighter)
  const viewboxDeltaDeg = 0.3;

  function determineBiasCoord(){
    return new Promise((resolve) => {
      if (navigator.geolocation){
        navigator.geolocation.getCurrentPosition(async (pos) => {
          biasLat = pos.coords.latitude;
          biasLon = pos.coords.longitude;
          statusEl.textContent = 'Suggestions will be biased to your area';
          setTimeout(()=>{ if (statusEl.textContent === 'Suggestions will be biased to your area') statusEl.textContent = ''; }, 2500);
          resolve({lat: biasLat, lon: biasLon, source: 'gps'});
        }, async (err) => {
          try {
            const resp = await fetch('/_client_location');
            const j = await resp.json();
            if (j && j.ok && j.lat && j.lon){
              biasLat = parseFloat(j.lat);
              biasLon = parseFloat(j.lon);
              statusEl.textContent = 'Suggestions will be biased to your city';
              setTimeout(()=>{ if (statusEl.textContent === 'Suggestions will be biased to your city') statusEl.textContent = ''; }, 2500);
              resolve({lat: biasLat, lon: biasLon, source: 'ip', city: j.city});
              return;
            }
          } catch(e){
            console.warn('IP location lookup failed', e);
          }
          biasLat = DEFAULT_FALLBACK.lat;
          biasLon = DEFAULT_FALLBACK.lon;
          statusEl.textContent = 'Showing suggestions near New York (default)';
          setTimeout(()=>{ if (statusEl.textContent === 'Showing suggestions near New York (default)') statusEl.textContent = ''; }, 3000);
          resolve({lat: biasLat, lon: biasLon, source: 'fallback'});
        }, { timeout: 8000, maximumAge: 60*1000 });
      } else {
        (async ()=>{
          try {
            const resp = await fetch('/_client_location');
            const j = await resp.json();
            if (j && j.ok && j.lat && j.lon){
              biasLat = parseFloat(j.lat);
              biasLon = parseFloat(j.lon);
              statusEl.textContent = 'Suggestions will be biased to your city';
              setTimeout(()=>{ if (statusEl.textContent === 'Suggestions will be biased to your city') statusEl.textContent = ''; }, 2500);
              resolve({lat: biasLat, lon: biasLon, source: 'ip', city: j.city});
              return;
            }
          } catch(e){
            console.warn('IP location lookup failed', e);
          }
          biasLat = DEFAULT_FALLBACK.lat;
          biasLon = DEFAULT_FALLBACK.lon;
          statusEl.textContent = 'Showing suggestions near New York (default)';
          setTimeout(()=>{ if (statusEl.textContent === 'Showing suggestions near New York (default)') statusEl.textContent = ''; }, 3000);
          resolve({lat: biasLat, lon: biasLon, source: 'fallback'});
        })();
      }
    });
  }

  function showPreview(lat,lng){
    if (!lat || !lng) return;
    const src = `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lng}&zoom=14&size=420x220&markers=${lat},${lng},red-pushpin`;
    preview.src = src;
    previewWrapper.style.display = 'block';
  }

  function clearSuggestions(){
    items = [];
    selectedIndex = -1;
    suggestions.innerHTML = '';
    suggestions.style.display = 'none';
    locInput.setAttribute('aria-expanded','false');
  }

  function renderSuggestions(list){
    suggestions.innerHTML = '';
    if (!list || list.length === 0){ clearSuggestions(); return; }
    list.forEach((it, idx) => {
      const el = document.createElement('div');
      el.className = 'addr-suggestion';
      el.setAttribute('role','option');
      el.setAttribute('data-idx', idx);
      el.tabIndex = -1;
      el.innerHTML = `<div>${it.display_name}</div><small>${it.type || ''}</small>`;
      el.addEventListener('click', ()=> selectSuggestion(idx));
      suggestions.appendChild(el);
    });
    suggestions.style.display = 'block';
    locInput.setAttribute('aria-expanded','true');
  }

  function selectSuggestion(idx){
    if (!items[idx]) return;
    const it = items[idx];
    locInput.value = it.display_name;
    latHidden.value = it.lat;
    lngHidden.value = it.lon;
    latManual.value = it.lat;
    lngManual.value = it.lon;
    showPreview(it.lat, it.lon);
    clearSuggestions();
    statusEl.textContent = 'Selected location';
  }

  async function fetchSuggestions(q){
    if (!q) { clearSuggestions(); return; }
    statusEl.textContent = 'Searching…';
    try {
      const params = new URLSearchParams({ q: q, format: 'json', addressdetails: '0', limit: '6' });
      if (biasLat !== null && biasLon !== null){
        const minLat = (biasLat - viewboxDeltaDeg).toFixed(6);
        const minLon = (biasLon - viewboxDeltaDeg).toFixed(6);
        const maxLat = (biasLat + viewboxDeltaDeg).toFixed(6);
        const maxLon = (biasLon + viewboxDeltaDeg).toFixed(6);
        params.append('viewbox', `${minLon},${minLat},${maxLon},${maxLat}`);
      }
      const res = await fetch('https://nominatim.openstreetmap.org/search?' + params.toString(), {
        headers: { 'Accept': 'application/json' }
      });
      if (!res.ok) { statusEl.textContent = 'Lookup failed'; return; }
      const arr = await res.json();
      items = (arr || []).map(a => ({ display_name: a.display_name, lat: a.lat, lon: a.lon, type: a.type }));
      renderSuggestions(items);
      statusEl.textContent = items.length ? '' : 'No matches';
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Lookup error';
    }
  }

  const debouncedFetch = debounce((q)=> fetchSuggestions(q), 300);

  // Initialize bias coordinates before user types
  determineBiasCoord().then(info => {
    // biasLat/biasLon now set; nothing else needed
  });

  locInput.addEventListener('input', (e)=>{
    const v = e.target.value.trim();
    latHidden.value = '';
    lngHidden.value = '';
    latManual.value = '';
    lngManual.value = '';
    if (!v) { clearSuggestions(); statusEl.textContent=''; return; }
    debouncedFetch(v);
  });

  locInput.addEventListener('keydown', function(e){
    if (suggestions.style.display === 'none') return;
    const max = Math.max(0, suggestions.children.length - 1);
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = Math.min(max, selectedIndex + 1);
      updateAriaSelection();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = Math.max(0, selectedIndex - 1);
      updateAriaSelection();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0) selectSuggestion(selectedIndex);
    } else if (e.key === 'Escape') {
      clearSuggestions();
    }
  });

  function updateAriaSelection(){
    Array.from(suggestions.children).forEach((ch, i)=>{
      if (i === selectedIndex) {
        ch.setAttribute('aria-selected','true');
        ch.scrollIntoView({ block:'nearest' });
      } else {
        ch.setAttribute('aria-selected','false');
      }
    });
  }

  document.addEventListener('click', (e)=>{
    if (!suggestions.contains(e.target) && e.target !== locInput) clearSuggestions();
  });

  findBtn.addEventListener('click', async function(){
    const addr = locInput.value && locInput.value.trim();
    if (!addr){
      statusEl.textContent = 'Enter an address first.';
      return;
    }
    statusEl.textContent = 'Looking up address…';
    await fetchSuggestions(addr);
    if (items && items.length > 0) {
      selectSuggestion(0);
    }
  });

  latManual.addEventListener('input', ()=> { latHidden.value = latManual.value; showPreview(latHidden.value, lngHidden.value); });
  lngManual.addEventListener('input', ()=> { lngHidden.value = lngManual.value; showPreview(latHidden.value, lngManual.value); });

  if (latHidden.value && lngHidden.value) showPreview(latHidden.value, lngHidden.value);
})();
</script>
{% endblock %}
